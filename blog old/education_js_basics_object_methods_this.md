---
title: JS-Основы | Методы объекта, "this"
thumbnail: post_cheat_sheet_nuxtjs.png
---

### Содержание
[Примеры методов](#method_examples)  
[Сокращённая запись метода](#method_shorthand)  
[Ключевое слово «this» в методах](#this_in_methods)  
[Итого](#total)  
[Задачи](#exercise)  


Объекты обычно создаются, чтобы представлять сущности реального мира, будь то пользователи, заказы и так далее:

```js
// Объект пользователя
let user = {
  name: "Джон",
  age: 30
};
```

И так же, как и в реальном мире, пользователь может совершать действия: выбирать что-
то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п.

Такие действия в JavaScript представлены свойствами-функциями объекта.

<a name="method_examples"><h3>Примеры методов</h3></a>
Для начала давайте научим нашего пользователя user здороваться:

```js
let user = {
  name: "Джон",
  age: 30
};
user.sayHi = function() {
  alert("Привет!");
};
user.sayHi(); // Привет!
```
Здесь мы просто использовали `Function Expression` (функциональное выражение), чтобы
создать функцию для приветствия, и присвоили её свойству `user.sayHi` нашего
объекта.

Затем мы вызвали её. Теперь пользователь может говорить!

Функцию, которая является свойством объекта, называют методом этого объекта.

Итак, мы получили метод `sayHi` объекта `user`.

Конечно, мы могли бы заранее объявить функцию и использовать её в качестве метода,
примерно так:

```js
let user = {
  // ...
};
// сначала объявляем
function sayHi() {
  alert("Привет!");
};
// затем добавляем в качестве метода
user.sayHi = sayHi;
user.sayHi(); // Привет!
```

>**Объектно-ориентированное программирование**
>
>Когда мы пишем наш код, используя объекты для представления сущностей реального мира, – это называется объектно-ориентированное программирование  или сокращённо: «ООП».
>
>ООП является большой предметной областью и интересной наукой само по себе. Как выбрать правильные сущности? Как организовать взаимодействие между ними? Это – создание архитектуры, и есть хорошие книги по этой теме, такие как «Приёмы объектно-ориентированного проектирования. Паттерны проектирования» авторов Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес или «Объектно-ориентированный анализ и проектирование с примерами приложений» Гради Буча, а также ещё множество других книг.

<a name="method_shorthand"><h3>Сокращённая запись метода</h3></a>

Существует более короткий синтаксис для методов в литерале объекта:

```js
// эти объекты делают одно и то же (одинаковые методы)
user = {
  sayHi: function() {
  alert("Привет");
}
};
// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function()"
    alert("Привет");
  }
};
```
Как было показано, мы можем пропустить ключевое слово `"function"` и просто написать `sayHi()`.

Нужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов (что будет рассмотрено позже), но на данном этапе изучения это неважно. В большинстве случаев сокращённый синтаксис предпочтителен.

<a name="this_in_methods"><h3>Ключевое слово «this» в методах</h3></a>  

Как правило, методу объекта необходим доступ к информации, которая хранится в объекте, чтобы выполнить с ней какие-либо действия (в соответствии с назначением метода).

Например, коду внутри `user.sayHi()` может понадобиться имя пользователя, которое хранится в объекте `user`.

Для доступа к информации внутри объекта метод может использовать ключевое слово `this`.

Значение `this` – это объект «перед точкой», который использовался для вызова метода.

Например:
```js
let user = {
  name: "Джон",
  age: 30,
  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }
};
user.sayHi(); // Джон
```

Здесь во время выполнения кода `user.sayHi()` значением `this` будет являться `user` (ссылка на объект `user` ).

Технически также возможно получить доступ к объекту без ключевого слова `this`, ссылаясь на него через внешнюю переменную (в которой хранится ссылка на этот объект):

```js
let user = {
  name: "Джон",
  age: 30,
  sayHi() {
    alert(user.name); // используем переменную "user" вместо ключевого слова "this"
  }
};
```

…Но такой код будет ненадёжным. Если мы решим скопировать ссылку на объект `user` в другую переменную, например, `admin = user` , и перезапишем переменную `user` чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из `admin`.

Это показано ниже:

```js
let user = {
  name: "Джон",
  age: 30,
  sayHi() {
    alert( user.name ); // приведёт к ошибке
  }
};
let admin = user;
user = null; // обнулим переменную для наглядности, теперь она не хранит ссылку на объект.
admin.sayHi(); // Ошибка! Внутри sayHi() используется user, которая больше не ссылается на объек
```

Если мы используем this.name вместо user.name внутри alert , тогда этот код будет работать.

### «this» не является фиксированным

В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Оно может использоваться в любой функции.

В этом коде нет синтаксической ошибки:

```js
function sayHi() {
  alert( this.name );
}
```
Значение `this` вычисляется во время выполнения кода и зависит от контекста.

Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» при вызовах:

```js
let user = { name: "Джон" };
let admin = { name: "Админ" };

function sayHi() {
  alert( this.name );
}
// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// вызовы функции, приведённые ниже, имеют разное значение this
// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
user.f(); // Джон (this == user)
admin.f(); // Админ (this == admin)
admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)
```

Правило простое: при вызове `obj.f()` значение `this` внутри `f` равно `obj` . Так что, в приведённом примере это `user` или `admin`.

> **Вызов без объекта: this == undefined**
>
>Мы даже можем вызвать функцию вовсе без использования объекта:
>```js
>function sayHi() {
>  alert(this);
>}
>sayHi(); // undefined
>```
>
>В строгом режиме `( "use strict" )` в таком коде значением `this` будет являться undefined . Если мы попытаемся получить доступ к name , используя `this.name` – это вызовет ошибку.
>
>В нестрогом режиме значением `this` в таком случае будет глобальный объект ( window для браузера, мы вернёмся к этому позже в главе Глобальный объект). Это – исторически сложившееся поведение `this` , которое исправляется использованием строгого режима ( "use strict" ).
>
>Обычно подобный вызов является ошибкой программирования. Если внутри функции используется `this` , тогда ожидается, что она будет вызываться в контексте какого-либо объекта.

> **Последствия свободного `this`**
>
>Если вы до этого изучали другие языки программирования, тогда вы, скорее всего, привыкли к идее "фиксированного this " – когда методы, определённые внутри объекта, всегда сохраняют в качестве значения `this` ссылку на свой объект (в котором был определён метод).
>
>В JavaScript `this` является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а зависит от того, какой объект вызывает метод (какой объект стоит «перед точкой»).
>
>Эта идея вычисления `this` в момент исполнения имеет как свои плюсы, так и минусы. С одной стороны, функция может быть повторно использована в качестве метода у различных объектов (что повышает гибкость). С другой стороны, большая гибкость увеличивает вероятность ошибок.
>
>Здесь мы не будем судить о том, является ли это решение в языке хорошим или плохим. Мы должны понимать, как с этим работать, чтобы получать выгоды и избегать проблем.

### Внутренняя реализация: Ссылочный тип

<a name="total"><h3>Итого</h3></a>

- Функции, которые находятся в объекте в качестве его свойств, называются «методами».
- Методы позволяют объектам «действовать» `object.doSomething()`.
- Методы могут ссылаться на объект через `this`.

Значение this определяется во время исполнения кода.

- При объявлении любой функции в ней можно использовать `this`, но этот `this` не имеет значения до тех пор, пока функция не будет вызвана.
- Эта функция может быть скопирована между объектами (из одного объекта в другой).
- Когда функция вызывается синтаксисом «метода» – `object.method()`, значением `this` во время вызова является объект перед точкой.

Также ещё раз заметим, что стрелочные функции являются особенными – у них нет `this`. Когда внутри стрелочной функции обращаются к `this`, то его значение берётся снаружи.

<a name="exercise"><h3>Задачи</h3></a>


***
**Ex1 - Проверка синтаксиса**
*важность: 2*

Каким будет результат выполнения этого кода?

```js
let user = {
  name: "Джон",
  go: function() { alert(this.name) }
}
(user.go)()
```

***

**Ex2 - Объясните значение "this"**
*важность: 3*

В представленном ниже коде мы намерены вызвать user.go() метод 4 раза подряд.

Но вызовы (1) и (2) работают иначе, чем (3) и (4) . Почему?

```js
let obj, method;

obj = {
  go: function() { alert(this); }
};

obj.go(); // (1) [object Object]

(obj.go)(); // (2) [object Object]

(method = obj.go)(); // (3) undefined

(obj.go || obj.stop)(); // (4) undefined
```
***

**Ex3 - Использование `"this"` в литерале объекта**
*важность: 5*

Здесь функция makeUser возвращает объект.

Каким будет результат при обращении к свойству объекта ref ? Почему?

```js
function makeUser() {
  return {
    name: "Джон",
    ref: this
  };
};

let user = makeUser();

alert( user.ref.name ); // Каким будет результат?
```

***

**Ex4 - Создайте калькулятор**
*важность: 5*

Создайте объект calculator (калькулятор) с тремя методами:

`read()` (читать) запрашивает два значения и сохраняет их как свойства объекта.
`sum()` (суммировать) возвращает сумму сохранённых значений.
`mul()` (умножить) перемножает сохранённые значения и возвращает результат.

```js
let calculator = {
  // ... ваш код ...
};

calculator.read();

alert( calculator.sum() );

alert( calculator.mul() );
```
**Решение:**
```js
let calculator = {
  read() {
    this.x = +prompt('x', 0);
    this.y = +prompt('y', 0);
  },
  sum() {
    return this.x + this.y
  },
  mul() {
    return this.x * this.y
  }
};

calculator.read();

alert(calculator.sum());

alert(calculator.mul());
```

<iframe height="400px" width="100%" src="https://repl.it/@ZAPASA/JS-or-Objectmethodsthis-or-Ex4?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>

***

**Ex5 - Цепь вызовов**
*важность: 2*

Это ladder (лестница) – объект, который позволяет подниматься вверх и спускаться:

```js
let ladder = {
  step: 0,
  up() {
   this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // показывает текущую ступеньку
    alert( this.step );
  }
};
```

Теперь, если нам нужно сделать несколько последовательных вызовов, мы можем выполнить это так:

```js
ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
```
Измените код методов up , down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:

```js
ladder.up().up().down().showStep(); // 1
```
Такой подход широко используется в библиотеках JavaScript.

**Мое Решение**
```js
let ladder = {
  step: 0,
  up() {
    this.step++;
    return this
  },
  down() {
    this.step--;
    return this
  },
  showStep: function () { // показывает текущую ступеньку
    console.log(this.step);
  }
};

ladder.up().up().down().showStep();
```

**Решение**

Решением является возврат самого объекта в каждом методе.

```js
  Аналогично
```

Мы также можем писать один вызов на одной строке. Для длинной цепи вызовов это более читабельно:

```js
ladder
  .up()
  .down()
  .up()
  .down()
  .showStep(); // 1
```

<script async src="//jsfiddle.net/ZAPASA/gok41cwu/2/embed/js,html/dark/"></script>