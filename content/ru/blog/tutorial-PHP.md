---
title: PHP
description: "| PHP Tutorial"
date: 2021-12-29
---


```php
    error_reporting(-1); //  вывод предупреждений
```
## ТИПЫ ДАННЫХ


- boolean: true/false (TRUE/FALSE, True/False)
- integer: целое чило
- float: число с плавающей точуой
- string
- NULL

### Строки

`''` - переменные не обрабатываются!!!  
`""` - переменные обрабатываются

Экранирование строки: `\'`, `\$`, ....

```php
// HEREDOC
$str3 =<<<HERE //любое слово. после него только перевод строки, иначе ошибка. Закрывать точно таким же слово.
This is "string". $var // переменные не обрабатываются
HERE; // После, обязательны перевод строки или 
```

```php
// NOWDOC

$str4 =<<<'HERE' //любое слово. после него только перевод строки, иначе ошибка. Закрывать точно таким же слово.
This is 'string'. $var // переменные не обрабатываются
HERE; // После, обязательны перевод строки или 
```

### Приведения типов

## ОПЕРАТОРЫ
- [php.net - Операторы](https://www.php.net/manual/ru/language.operators.php)

```php
`$a + $b`, `$a - $b`, `$a * $b`, `$a / $b`  
`$a % $b`  
`$a ** $b` // возведение в степинь (PHP 5.6). Аналог - функция `pow( x, n )`  
`>`, `<`, `<=`, `>=`  
`!=` // не равно  
`=` // присваевание  
```
```php
`&` // присваевание по ссылке

$a = 5;
$b = $a; // новая ячейка памяти
var_damp($a, $b) // 5, 5
$a = 7;
var_damp($a, $b) // 7, 5

$a = 5;
$b = &$a; // новая ячейка памяти не создается, $b ссылается на ячейку $a
var_damp($a, $b) // 5, 5
$a = 7;
var_damp($a, $b) // 7, 7
```
```php
`==` // сравнение  
`===`, `!==` //   
`++$a` // префиксный инкремент  
`$a++` // постфиксный инкремент, аналоги $a = $a + 1, $a += 1  
`--$a` // перфиксный декркмент  
`$a--` // постфиксный декремент  
`.` // конкатенация  
`+=`, `-=`, `*=`, `/=`, `.=` // комбинированые операторы `$a = $a + 2 $a += 2`
```
```php
`<=>` // Космический корабль (spaceship).

// Целые числа
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Числа с плавающей точкой
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Строки
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1

echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Массивы
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Объекты
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0

$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1

$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// сравниваются не только значения; ключи также должны совпадать
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1
```

## УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ

- if
- else
- elseif
- switch case

### IF, ELSE, ELSEIF

```php
if() ...;
if() {...};
if() {...} else {...};
if() {...} elseif {...};
if() {...} elseif {...} else {...};
if() {...} elseif {...} elseif {...};
if() {...} elseif {...} elseif {...} else {...};
```

### SWITCH CASE

```php
$var = 3;

svitch($var) {
    case 1:
        echo 'Variable = 1';
    break;
    case 2:
        echo 'Variable = 2';
    break;
    case 3:
        echo 'Variable = 3';
    break;
    default:
        echo 'Something else...';
}
```

### Альткрнативный синтаксис управляющих структур

Для:
- if
- while
- for
- forech
- switch

### require, include, require_once, include_once

`require` - в случае ошибки останавлевает скрипт

`include` - в случае ошибки продолжает скрипт


### return

## ПЕРЕМЕННЫЕ

```php
$name = 'ZAPA';
```

## МАССИВЫ

### База

```php
$arr = arrey('Ivanov', 'Petrov', 'Sidorov');
$arr = ['Ivanov', 'Petrov', 'Sidorov'] // с версии PHP 5.4

echo $arr[0]; // аналог $arr{0}
$arr[] = 'Pupkin'; // добавить элемент в конец масива
$arr[5] = 'Pupkin'; // добавить элемент в позицию с ключем "5" 
```

```php
$countrys = ['USA', 'Canad', 'Spain'];

// многомерный, асоциативный массив
$friends = [
    'friend1' => [
        'name'  => 'Den',
        'age'   => 25,
    ],
    'friend2' => [
        'name'  => 'Tom',
      'age'   => 18,
    ]
];

echo $namesss;
echo $countrys[0];
echo $friends['friend2']['name'];
```

### Функции для роботы с массивом

```php

```

## ЦИКЛЫ

- while
- do-while
- for
- foreach

### while
```php
while (expr)
    statement
```
```php
while (expr):
    statement
    ...
endwhile;
```

Примеры:
```php
$i = 1;
while ($i < 10) {
  echo $i;
  $i++;
}

$i = 1;
while($i < 10){
  echo $i++;
}
```

```php

$i = 1;
echo "<table border=\"1\">\n";
while($i <= 15){
  echo "\t<tr>\n";
  $n = 1;
  while($n <= 5){
    echo "\t\t<td>Row $i | Col - $n</td>\n";
    $n++;
  }
  echo "\t</tr>\n";
  $i++;
}
echo '</table>';
```

```php
$year = 1900;
echo '<select>' . "\n";
  while($year <= 2015){
    echo "\t<option value='$year'>$year</option>\n";
    $year++;
  }
echo '</select>';
```

### do-while

```php
$i = 10;
do {
  echo $i++ . '<br>';
} while ($i <= 10);
```


```php
$countrys = ['USA', 'Canad', 'Spain'];

foreach ($countrys as $country) {
	echo $country . ' ';
}
```

### for

### foreach

## ФУНКЦИИ
- [php.net - Документация](https://www.php.net/manual/ru/funcref.php)


### Сигнатура фунции

**Сигнатура** — это описание функции (метода), включающее в себя:

- Модификатор доступа
- Имя функции (метода)
- Список аргументов, где для каждого аргумента указано:
    - Тип
    - Имя
    - Значение по умолчанию
    - либо оператор «три точки»
- Тип возвращаемого значения

Примеры:
```php
function ();
public function foo($arg = null);
protected function sum(int $x, int $y, ...$args): int;
```

```php
pow ( number $base , number $exp ) : number

// Информация расшифровывается так:
// - функция называется pow
// - функция принимает два параметра: число (base) и число (exp)
// - функция возвращает число (number)

```

#### Совместимость сигнатур

Предположим, что у нас есть две функции, A и B.
Сигнатура функции B считается совместимой с A (порядок важен, отношение несимметрично!) в строгом смысле, если:

**Они полностью совпадают**
```php
//Тривиальный случай, комментировать тут нечего.
```

**B добавляет к A аргументы по умолчанию**

```php
// A:
function foo($x);

// совместимые B:
function foo($x, $y = null);
function foo($x, ...$args);
```

**B сужает область значений A**

```php
// A:
function foo(int $x);
// совместимые B:
// В A допускался возврат любых значений, в B эта область сужена только до целых чисел
function foo(int $x): int;
```

### Пользовательские функции в PHP

### Функция header в PHP

### Функции работы со строками в PHP

[php.net - Функции для работы со строками](https://www.php.net/manual/ru/ref.strings.php)

```php
addcslashes()  // Экранирует строку слешами в стиле языка C
addslashes()  // Экранирует строку с помощью слешей
bin2hex()  // Преобразует бинарные данные в шестнадцатеричное представление
chop()  // Псевдоним rtrim
chr()  // Генерирует односимвольную строку по заданному числу
chunk_split()  // Разбивает строку на фрагменты
convert_cyr_string()  // Преобразует строку из одной кириллической кодировки в другую                                       
convert_uudecode()  // Декодирует строку из формата uuencode в обычный вид                                                
convert_uuencode()  // Кодирует строку в формат uuencode                                                                  
count_chars()  // Возвращает информацию о символах, входящих в строку                                                
crc32()  // Вычисляет полином CRC32 для строки                                                                 
crypt()  // Необратимое хеширование строки                                                                     
echo  // Выводит одну или более строк                                                                       
explode()  // Разбивает строку с помощью разделителя                                                             
fprintf()  // Записывает отформатированную строку в поток                                                        
get_html_translation_table()  // Возвращает таблицу преобразований, используемую функциями htmlspecialchars и htmlentities          
hebrev()  // Преобразует текст на иврите из логической кодировки в визуальную                                   
hebrevc()  // Преобразует текст на иврите из логической кодировки в визуальную с преобразованием перевода строки 
hex2bin()  // Преобразует шестнадцатеричные данные в двоичные                                                    
html_entity_decode()  // Преобразует HTML-сущности в соответствующие им символы                                             
htmlentities()  // Преобразует все возможные символы в соответствующие HTML-сущности                                  
htmlspecialchars_decode()  // Преобразует специальные HTML-сущности обратно в соответствующие символы                            
htmlspecialchars()  // Преобразует специальные символы в HTML-сущности                                                    
implode()  // Объединяет элементы массива в строку                                                               
join()  // Псевдоним implode                                                                                  
lcfirst()  // Преобразует первый символ строки в нижний регистр                                                  
levenshtein()  // Вычисляет расстояние Левенштейна между двумя строками                                              
localeconv()  // Возвращает информацию о форматировании чисел                                                       
ltrim()  // Удаляет пробелы (или другие символы) из начала строки                                              
md5_file()  // Возвращает MD5-хеш файла                                                                           
md5()  // Возвращает MD5-хеш строки                                                                          
metaphone()  // Возвращает ключ metaphone для строки                                                               
money_format()  // Форматирует число как денежную величину                                                            
nl_langinfo()  // Возвращает информацию о языке и локали                                                             
nl2br()  // Вставляет HTML-код разрыва строки перед каждым переводом строки                                    
number_format()  // Форматирует число с разделением групп                                                              
ord()  // Конвертирует первый байт строки в число от 0 до 255                                                
parse_str()  // Разбирает строку в переменные                                                                      
print // Выводит строку                                                                                     
printf()  // Выводит отформатированную строку                                                                   
quoted_printable_decode()  // Преобразует строку, закодированную методом quoted-printable в 8-битную строку                      
quoted_printable_encode()  // Преобразует 8-битную строку с помощью метода quoted-printable                                      
quotemeta()  // Экранирует специальные символы                                                                     
rtrim()  // Удаляет пробелы (или другие символы) из конца строки                                               
setlocale()  // Устанавливает настройки локали                                                                     
sha1_file()  // Возвращает SHA1-хеш файла                                                                          
sha1()  // Возвращает SHA1-хеш строки                                                                         
similar_text()  // Вычисляет степень похожести двух строк                                                             
soundex()  // Возвращает ключ soundex для строки                                                                 
```
```php
sprintf() // Возвращает отформатированную строку

$num = 5;
$location = 'tree';
$format = 'There are %d monkeys in the %s';

echo sprintf($format, $num, $location);
```

```php
sscanf()  // Разбирает строку в соответствии с заданным форматом   
str_contains()  // Определяет, содержит ли строка заданную подстроку     
str_ends_with()  // Проверяет, заканчивается ли строка заданной подстрокой
str_getcsv()  // Выполняет разбор CSV-строки в массив                  
str_ireplace()  // Регистронезависимый вариант функции str_replace       
str_pad()  // Дополняет строку другой строкой до заданной длины     
str_repeat()  // Возвращает повторяющуюся строку                       
```
```php
str_replace() // Заменяет все вхождения строки поиска на строку замены

$str = '[i]Hello![/i] my name is [b]Bob[/b]';
$search = ['[i]', '[/i]', '[b]', '[/b]'];
$replace = ['<i>', '</i>', '<b>', '</b>'];
$str = str_replace( $search, $replace. $str );
```

```php
str_rot13()      // Выполняет преобразование ROT13 над строкой                                    
str_shuffle()    // Переставляет символы в строке случайным образом                               
str_split()      // Преобразует строку в массив                                                   
str_starts_with()// Проверяет, начинается ли строка с заданной подстроки                          
str_word_count() // Возвращает информацию о словах, входящих в строку                             
strcasecmp()     // Бинарно-безопасное сравнение строк без учёта регистра                         
strchr()         // Псевдоним strstr                                                              
strcmp()         // Бинарно-безопасное сравнение строк                                            
strcoll()        // Сравнение строк с учётом текущей локали                                       
strcspn()        // Возвращает длину участка в начале строки, не соответствующего маске           
strip_tags()     // Удаляет теги HTML и PHP из строки                                             
stripcslashes()  // Удаляет экранирование символов, произведённое функцией addcslashes            
stripos()        // Возвращает позицию первого вхождения подстроки без учёта регистра             
stripslashes()   // Удаляет экранирование символов                                                
stristr()        // Регистронезависимый вариант функции strstr                                    
strlen()         // Возвращает длину строки                                                       
strnatcasecmp()  // Сравнение строк без учёта регистра с использованием алгоритма "natural order" 
strnatcmp()      // Сравнение строк с использованием алгоритма "natural order"                    
strncasecmp()    // Бинарно-безопасное сравнение первых n символов строк без учёта регистра       
strncmp()        // Бинарно-безопасное сравнение первых n символов строк                          
strpbrk()        // Ищет в строке любой символ из заданного набора                                
strpos()         // Возвращает позицию первого вхождения подстроки                                
strrchr()        // Находит последнее вхождение символа в строке                                  
strrev()         // Переворачивает строку задом наперёд                                           
strripos()       // Возвращает позицию последнего вхождения подстроки без учёта регистра          
strrpos()        // Возвращает позицию последнего вхождения подстроки в строке                    
strspn()         // Возвращает длину участка в начале строки, полностью соответствующего маске    
strstr()         // Находит первое вхождение подстроки                                            
strtok()         // Разбивает строку на токены
strtolower()     // Преобразует строку в нижний регистр                                               
strtoupper()     // Преобразует строку в верхний регистр                                              
strtr()          // Преобразует заданные символы или заменяет подстроки                               
substr_compare() // Бинарно-безопасное сравнение 2 строк со смещением, с учётом или без учёта регистра
substr_count()   // Возвращает число вхождений подстроки                                              
substr_replace() // Заменяет часть строки                                                             
substr()         // Возвращает подстроку                                                              
```
```php
trim() //удаляет пробелы (или другие символы) из начала и конца строки;

// Эта функция возвращает строку string с удалёнными из начала и конца строки пробелами. Если второй параметр не передан, trim() удаляет следующие символы:
// " " (ASCII 32 (0x20)), обычный пробел.
// "\t" (ASCII 9 (0x09)), символ табуляции.
// "\n" (ASCII 10 (0x0A)), символ перевода строки.
// "\r" (ASCII 13 (0x0D)), символ возврата каретки.
// "\0" (ASCII 0 (0x00)), NUL-байт.
// "\v" (ASCII 11 (0x0B)), вертикальная табуляция.

```
```php
ucfirst()  // Преобразует первый символ строки в верхний регистр                
ucwords()  // Преобразует в верхний регистр первый символ каждого слова в строке
vfprintf() // Записывает отформатированную строку в поток                       
vprintf()  // Выводит отформатированную строку                                  
vsprintf() // Возвращает отформатированную строку                               
wordwrap() // Переносит строку по указанному количеству символов                
```

```php
explode() // разбивает строку с помощью разделителя;
implode() // объединяет элементы массива в строку // join() — Псевдоним implode();
ltrim() // Удаляет пробелы (или другие символы) из начала строки;
rtrim() // Удаляет пробелы (или другие символы) из конца строки;
nl2br() // Вставляет HTML-код разрыва строки перед каждым переводом строки
str_ireplace() // Регистронезависимый вариант функции str_replace()
strip_tags() // Удаляет теги HTML и PHP из строки
strlen() // Возвращает длину строки. !!! Считает количество байтов, а не символов !!!
```

```php
mb_strlen() // Получает длину строки

$str = "Привет";
echo mb_strlen( $str, 'utf-8' ); // вернет правильное значение
```

```php
strpos(), mb_strpos() // Возвращает позицию первого вхождения подстроки
```

```php
strtolower(), mb_strtolower() // Преобразует строку в нижний регистр
strtoupper(), mb_strtoupper() // Преобразует строку в верхний регистр
```

```php
substr(), mb_substr() // Возвращает подстроку
```

```php
htmlspecialchars() // Преобразует специальные символы в HTML-сущности
```











### Функции даты и времени в PHP

[php.net - Функции даты и времени](https://www.php.net/manual/ru/ref.datetime.php)

```php
checkdate() // Проверяет корректность даты по григорианскому календарю 
date_add() // Псевдоним DateTime::add
date_create_from_format() // Псевдоним DateTime::createFromFormat
date_create_immutable_from_format() // Псевдоним DateTimeImmutable::createFromFormat
date_create_immutable() // Псевдоним DateTimeImmutable::__construct
date_create() // Псевдоним DateTime::__construct
date_date_set() // Псевдоним DateTime::setDate
date_default_timezone_get() // Возвращает часовой пояс, используемый по умолчанию всеми функциями даты/времени в скрипте 
date_default_timezone_set() // Устанавливает часовой пояс по умолчанию для всех функций даты/времени в скрипте 
date_diff() // Псевдоним DateTime::diff
date_format() // Псевдоним DateTime::format
date_get_last_errors() // Псевдоним DateTime::getLastErrors
date_interval_create_from_date_string() // Псевдоним DateInterval::createFromDateString
date_interval_format() // Псевдоним DateInterval::format
date_isodate_set() // Псевдоним DateTime::setISODate
date_modify() // Псевдоним DateTime::modify
date_offset_get() // Псевдоним DateTime::getOffset
date_parse_from_format() // Получение информации о заданной в определённом формате дате
date_parse() // Возвращает ассоциативный массив с подробной информацией о заданной дате/времени
date_sub() // Псевдоним DateTime::sub
date_sun_info() // Возвращает массив с информацией о закате/рассвете и начале/окончании сумерек
date_sunrise() // Возвращает время рассвета для заданных дня и местоположения
date_sunset() // Возвращает время захода солнца для заданных дня и местоположения
date_time_set() // Псевдоним DateTime::setTime
date_timestamp_get() // Псевдоним DateTime::getTimestamp
date_timestamp_set() // Псевдоним DateTime::setTimestamp
date_timezone_get()  // Псевдоним DateTime::getTimezone
date_timezone_set()  // Псевдоним DateTime::setTimezone
date() // Форматирует вывод системной даты/времени
getdate() // Возвращает информацию о дате/времени
gettimeofday() // Возвращает текущее время
gmdate() // Форматирует дату/время по Гринвичу
gmmktime() // Возвращает локальную метку времени Unix для времени по Гринвичу
gmstrftime() // Форматирует дату/время по Гринвичу с учётом текущей локали
idate() // Преобразует локальное время/дату в целое число
localtime() // Возвращает локальное время
microtime() // Возвращает текущую метку времени Unix с микросекундами
mktime() // Возвращает метку времени Unix для заданной даты
strftime() // Форматирует текущую дату/время с учётом текущих настроек локали
strptime() // Разбирает строку даты/времени, сгенерированную функцией strftime
strtotime() // Преобразует текстовое представление даты на английском языке в метку времени Unix
time() // Возвращает текущую метку системного времени Unix
timezone_abbreviations_list() // Псевдоним DateTimeZone::listAbbreviations
timezone_identifiers_list() // Псевдоним DateTimeZone::listIdentifiers
timezone_location_get() // Псевдоним DateTimeZone::getLocation
timezone_name_from_abbr() // Возвращает часовой пояс в соответствии с аббревиатурой
timezone_name_get() // Псевдоним DateTimeZone::getName
timezone_offset_get() // Псевдоним DateTimeZone::getOffset
timezone_open() // Псевдоним DateTimeZone::__construct
timezone_transitions_get() // Псевдоним DateTimeZone::getTransitions
timezone_version_get() // Получение номера версии базы данных часовых поясов
```

##БУФЕР ВЫВОДА==

- [ОФФ ДОК - Управление буфером вывода](https://www.php.net/manual/ru/book.outcontrol.php)
- [ОФФ ДОК - ob_start](https://www.php.net/manual/ru/function.ob-start.php)
- [https://anton.shevchuk.name/php/php-for-beginners-output-buffer/](https://anton.shevchuk.name/php/php-for-beginners-output-buffer/)

Для начала, даю установку — буферов вывода в PHP несколько, плюс ещё модули web-сервера могут выполнять буферизацию, да ещё и браузеры могут играться с выводом и не сразу отображать полученный результат (надо бы тут освежить память, а то за упоминание Netscape могут освежевать).

Вот теперь буду рассказывать о буферизации в PHP.

### Пользовательский буфер вывода
Работа с буфером вывода начинается с функции `ob_start()` — у данной функции есть три опциональных параметра, но о них я расскажу чуть позже, а пока запоминаем — для включения буфера вывода используем функцию `ob_start()`:
```php
// включаем буфер
ob_start();
 
// этот, и весь последующий вывод, будет попадать в буфер вывода
echo "hello world";
```
Если же нам надо сохранить данные, или ещё как обработать вывод то нам потребуется функция `ob_get_contents()`. Сохранив данные, можно очистить и отключить буфер — для этого воспользуемся функцией `ob_end_clean()`, если свести всё перечисленное до кучи, то в результате получим следующий код:
```php
// включаем буфер
ob_start();
 
// выводим информацию
echo "hello world";
 
// сохраняем всё что есть в буфере в переменную $content
$content = ob_get_contents();
 
// отключаем и очищаем буфер
ob_end_clean();
```
> Практически все нужные нам функции имеют префикс «ob_», как не трудно догадаться это сокращение от «output buffer»

Функцию ob_get_contents() можно вызывать множество раз, на практике с таким не сталкивался:
```php
// включаем буфер
ob_start();
 
// выводим информацию
echo "hello ";
 
// сохраняем всё что есть в буфере в переменную
// на данный момент там только `hello `
$a = ob_get_contents();
 
// выводим информацию
echo "world ";
 
// повторный вызов
// теперь буфер содержит `hello world `
$b = ob_get_contents();
```
> Если вы стартанули буфер вывода, но по какой-то причине не закрыли его, то PHP это сделает за вас и в конце работы скрипта выполнит «сброс» буфера вывода в браузер пользователя

Если внутри блока ob_start – ob_end вы отправляете заголовок, то он не попадает в буфер, а сразу будет отправлен в браузер:
```php
header("OB-START: 1");
ob_start();
 
echo "Never saw";
header("PHP-VERSION: ". PHP_VERSION);
 
ob_end_clean();
header("OB-END: 1");
```

В результате выполнения данного кода в http-пакете появятся следующие заголовки:
```php
OB-START: 1
PHP-VERSION: 5.6.11-1+deb.sury.org~trusty+1
OB-END: 1
```
Естественно, данный код больше ничего не выводит, будет пустая страница.

Данное правило по отправке заголовков верно как для непосредственного вызова функции `header()`, так и для неявного при вызове `session_start()`:
```php
ob_start();
{
    echo "hello world";
    session_start();  // тут всё будет работать корректно
    $content = ob_get_contents();
}
ob_end_clean();
echo "<h1>".$content."</h1>";
```

> Перед вами небольшой life-hack – в PHP вы можете использовать скобочки `{}` для выделения некой логики в блоки, при этом никакой функциональной нагрузки они не несут, а вот читаемость кода – повышают

Чуть-чуть прояснили ситуацию — теперь в копилке наших знаний есть информация о том, как включить буфер, как получить из него данные, и как выключить. Что ещё интересное можно с ним вытворять? Да с ним практически ничего толком и не сделать — его можно отправить (сбросить) в браузер (ключевое слово flush), очистить (clean), отключить (end). Ну и скомбинировать это всё до кучи тоже можно:

- `ob_clean()` — читаем название функции как «очищаем буфер вывода»
- `ob_flush()` — «отправляем буфер вывода»
- `ob_end_clean()` — «буфер вывода отключаем и очищаем»
- `ob_end_flush()` — «буфер вывода отключаем и отправляем в браузер»
- `ob_get_clean()` — «получаем буфер вывода, очищаем и отключаем» — тут небольшой отступление от правила, эта функция должна именоваться как `ob_get_end_clean()`, но решили упростить, и выкинули end
- `ob_get_flush()` — «отправляем буфер вывода, очищаем и отключаем», `ob_get_end_flush()`

Что можно из перечисленного делать с буфером вывода, определяется третьим опциональным параметром $flags при вызове функции `ob_start()`, используется крайне редко

Для простого запоминания вот вам наглядная табличка по данному семейству функций:

|                 | вернёт | очистит | отправит | отключит |
|-----------------|:------:|:-------:|:--------:|:--------:|
| ob_get_contents | x      |         |          |          |
| ob_clean        |        | x       |          |          |
| ob_flush        |        |         | x        |          |
| ob_end_clean    |        | x       |          | x        |
| ob_end_flush    |        |         | x        | x        |
| ob_get_clean    | x      | x       |          | x        |
| ob_get_flush    | x      |         | x        | x        |


*Задание*
Дополните приведенный ниже код вызовом одной функции, чтобы он корректно вывел «hello world»:
```php
ob_start();
{
    echo "hello";
    $a = ob_get_contents();
    echo "world";
    $b = ob_get_contents();
}
ob_end_clean();
 
echo $a .' '. $b;
```


### Обработчик буфера
Пора вернуться к функции `ob_start()` и её первому параметру — `$output_callback` — обработчик буфера вывода.
В качестве обработчика буфера должна быть указана callback-функция, которая принимает содержимое буфера как входной параметр и должна вернуть строку после обработки:
```php
/**
 * @param  string  $buffer Содержимое буфера
 * @param  integer $phase  Битовая маска из значений PHP_OUTPUT_HANDLER_*
 * @return string
 */
function ob_handler ($buffer, $phase) {
    return "Length of string '$buffer' is ". strlen($buffer);
}
 
ob_start('ob_handler');
echo "hello world";
ob_end_flush();
```
В данном примере функция обработчик вернёт строку «Length of string ‘hello world’ is 11».

> Важный момент — с этими функциями нужно быть поосторожней, обработали строки и ладненько, но не пытайтесь вывести либо сохранить данные, не пытайтесь стартовать другой буфер вывода внутри функции, и да есть функции которые создают буфер вывода внутри себя, вот `print_r()` и `highlight_file()` тому пример

Из стандартных же обработчиков можете повстречать [https://www.php.net/function.ob-gzhandler](ob_gzhandler()), но лучше сжатие страничек оставлять на плечах web-сервера, и не вешать это на PHP.

> Ещё момент, второй параметр $phase callback-функции может включать в себя флаги из семейства `PHP_OUTPUT_HANDLER_*`, но вам эта информация никогда не понадобится, я даже пример не смог придумать, зачем оно надо.


### We need to go deeper

У буфера вывода есть килер-фича – внутри буфера можно стартовать ещё один буфер, а внутри нового ещё и так далее (пока памяти хватает):

```php
echo ob_get_level();              // 1
ob_start();
    echo ob_get_level();          // 2
    ob_start();
        echo ob_get_level();      // 3
        ob_start();
            echo ob_get_level();  // 4
        ob_end_flush();
    ob_end_flush();
ob_end_flush();
```

В данном примере функция `ob_flush()` и производные от неё, будут «выбрасывать» содержимое буфера на более высокий уровень.

Данный подход поможет в случае, когда вам нужно подключить сторонний код, а он вдруг может что-то взять и вывести — было бы разумно обернуть его вывод в буфер, даже если весь ваш код уже обёрнут в другой буфер.

Если вы не знаете точно на какой «глубине» находитесь – то воспользуйтесь функцией `ob_get_level()`, а чтобы «проснуться» вам пригодится следующий код:
```php
while (ob_get_level()) {
    ob_end_clean();
}
```

*Задание*
Внесите изменения в код с вложенными вызовами ob_start() таким образом, чтобы цифры выводились в обратном порядке, для этого надо переставить три строчки кода.


### Буфер «по умолчанию»

Если захотите создать обёртку над всем кодом, то для этого можно воспользоваться решением «из коробки» — буфер вывода «по умолчанию», за активацию оного отвечает директива output_buffering, её можно выставить как в On, так и указать размер буфера который нам потребуется (при достижении лимита, буфер будет отправлен в браузер пользователю).
Данная директива должна быть проставлена либо в php.ini, либо в .htaccess (для апача), попытка выставить данное значение с использование ini_set() ни к чему не приведёт, т.к. PHP уже стартанул, и буфер вывода уже сконфигурирован согласно настроек:
```
// .htaccess
1php_value output_buffering 4096
```
Если при включенном буфере проверить уровень вложенности и вызвать функцию `ob_get_level()`, то получим 1:

```php
if (ini_get('output_buffering')) {
    echo ob_get_level(); // 1
}
```
Т.е. если включить данный буфер, то можно будет избежать ошибок вида «headers already sent»?
Да, пока буфера хватит, но никогда так не делайте, ведь понадеявшись на данный метод, вы фактически заложите бомбу замедленного действия, и неизвестно когда она «рванёт» и посыпит ошибками:
```php
// сохраняем значение буфера
$buffer = ini_get('output_buffering');
 
// "выводим" текст на байт меньше буфера
echo str_pad('', $buffer - 1);
 
// отправляем заголовок
header("TAG-A: ". PHP_VERSION);
 
// ещё байт
echo " ";
 
// а второй заголовок уже не отправляется
// получите ошибку
header("TAG-B: ". PHP_VERSION);
```
> Запомните, для CLI приложений директива `output_buffering` всегда 0, т.е. данный буфер отключен

#### Зачем это всё?
Хороший вопрос — зачем нужна работа с буфером вывода? Приведу несколько основных сценариев использования:

1. Сжатие передаваемых данных — с использованием уже упомянутой `ob_gzhandler()`
2. Отложенный вывод, чтобы избежать ошибки «headers already sent» (о данной ошибке подробно рассказано в статье Сессия)
3. Работа с чужим кодом, который пытается самостоятельно что-то выводить
4. Работа с HTML файлами: когда вам надо подключать текстовый файл (обычно речь о HTML), для дальнейшей работы с его содержимым


Сценарий обработки ошибок в подключаемых файлах — стартуете буфер, подключаете файлы, если что-то пошло не так, то содержимое буфера можно скинуть, и вместо неинформативного сообщения об ошибке, выводите не менее информативное сообщение, что сервер приболел, и не может больше ничего.
Пример работы с критическими ошибками вы можете найти в статье [Обработка ошибок](https://anton.shevchuk.name/php/php-for-beginners-error-handling/), и там тоже упоминается буфер вывода, ох видать всё это ж-ж-ж неспроста

### Системный буфер вывода
С пользовательским буфером вывода разобрались, давайте теперь к системному перейдём — это такой буфер вывода, который наполняется по ходу выполнения скрипта, и отправляется в браузер по окончанию выполнения.
Т.е. данный буфер вывода есть всегда, его не нужно создавать, но мы можем им управлять.

Вот так всё просто и кратко, ну а теперь о нюансах управления системным буфером вывода…

![](IMG/flush.gif)

А теперь из академического интереса давайте рассмотрим реализацию данного «экшена» – там совсем чуть-чуть кода, и небольшая горстка полезных знаний по PHP:
```php
echo "<h3>Please waiting for 10 seconds...</h3>";
 
for ($i = 1; $i <= 10; $i++) {
    echo $i;
    flush();
    sleep(1);
}
 
echo "<h3>Thx!</h3>";
```

Сразу бросается в глаза вызов функции `flush()` — вызвав данную функцию вы даёте указание PHP «сбросить» системный буфер, т.е. отправить всё что там есть в браузер пользователю (но учтите, если у вас стартован пользовательский буфер, то для начала надо будет «сбросить» его, и уже потом вызвать `flush()`).
Т.е. происходящее можно описать как:
```
цикл на 10 итераций:
    - выводим число, вывод попадает в системный буфер
    - отправляем буфер пользователю в браузер
    - ждём секунду
```

Ещё одна особенность, о которой нужно помнить — директива [implicit_flush](https://www.php.net/outcontrol.configuration#ini.implicit-flush), отвечает за то, чтобы после каждого вывода автоматически вызывался `flush()`, поэтому следующая комбинация сработает аналогично предыдущему примеру:
```
// .htaccess

php_flag implicit_flush on
```
```php
for ($i = 1; $i <= 10; $i++) {
    echo $i;
    sleep(1);
}
```

Данную директиву можно изменять «на лету», для этого достаточно вызвать функцию `ob_implicit_flush()` (удивительное рядом, данную функцию стоило всё же назвать `implicit_flush()`, т.к. к пользовательскому буферу вывода она имеет опосредственное отношение — после вызова `ob_flush()` будет вызван `flush()`):
```php
ob_implicit_flush();
for ($i = 1; $i <= 10; $i++) {
    echo $i;
    sleep(1);
}
```

> Данные примеры работают только при выключенном `output_buffering`, иначе вам нужно будет его принудительно выключить и очистить в самом скрипте.
> Если же вы работаете в CLI, то знайте `implicit_flush` всегда включён, а `output_buffering` выключен, следовательно весь вывод будет без промедления попадать в консоль


*Задание*

Для выполнения данного задания вам потребуется освежить знания по [подключению файлов](https://anton.shevchuk.name/php/php-for-beginners-include-files/)

Для закрепления изученного материала, вам нужно реализовать простейший шаблонизатор, который оживит следующий код:

```php
$header = template('header', ['title' => 'Hello World!']);
$content = template('content', ['content' => "Lorem ipsum...", 'meta' => 'Author info']);
$footer = template('footer', ['copy' => "Copyright ". date('Y')]);
 
// ...skipped logic
 
echo $header, $content, $footer;
 
/**
 * @param  string $template
 * @param  array  $vars
 * @return string
 */
function template($template, $vars) {
    // place your code here
    // ...
}
```
Файлы шаблонов:
```php
<!-- header.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title><?=$title?></title>
</head>
<body>
<!-- content.phtml -->
<div class="container">
    <p><?=$content?></p>
    <p><?=$meta?></p>
</div>
<!-- footer.phtml -->
<footer>
    <?=$copy?>
</footer>
</body>
</html>
```



## Исключени
- [Исключения PHP: Try Catch для обработки ошибок](https://code.tutsplus.com/ru/tutorials/php-exceptions-try-catch-for-error-handling--cms-32013)


## NameSpace

- [Пространства имен](https://metanit.com/php/tutorial/4.4.php)
- [PHP Namespace](https://habr.com/ru/post/132736/)
- [Пространства имён в PHP](https://devacademy.ru/article/php/)
- [ЗАДАЧИ! Команда use и пространства имен](http://code.mu/ru/php/book/oop/namespaces/command-use/)
